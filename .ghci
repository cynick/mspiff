:set +s
:set +t
:set -W
:set -XOverloadedStrings
:set editor ec
:set prompt "Î»: "
:def! . readFile
:def! g (\_ -> return ":. .ghci\n")

:set -Wall

import qualified Data.List as DL
import Data.List.Split
import qualified Data.Map.Strict as M
import qualified Data.List.Split as DL
import qualified Control.Monad.Logic as L
import Data.Word
import Text.Printf
import Data.Either
import Data.Text.Read
import Data.Text
import Data.Time
import Data.Maybe
import Data.Array
import Data.These
import Mspiff.Model
import Mspiff.Loader
import Mspiff.Scheduler
import Instances

ts@(UTCTime d dt) <- getCurrentTime

s <- DL.sort <$> loadScreenings

let w = Schedule s
let s = scheduleScreenings w'
f <- DL.sort <$> loadFilms
let catalog = f
let (f0:f1:f2:f3:f4:f5:f6:f7:f8:f9:_) = f
let (s0:s1:s2:s3:s4:s5:s6:s7:s8:s9:_) = s
let scs@(sc1:sc2:sc3:_) = viewableSchedulesFor w (DL.take 10 f)
let s' = DL.concat $ fmap scheduleScreenings $ DL.take 1 $ viewableSchedulesFor w (DL.take 20 f)
let p = mapM_ print

let qc = quickCheckWith stdArgs { maxSuccess = 5000 }
let vc = verboseCheckWith stdArgs { maxSuccess = 5000 }
let hist v = DL.foldl' (\(a,b) v' -> if v' == v then (a+1,b) else (a,b+1)) (0,0)
let toIds t = fmap (fmap (fmap screeningId)) $ t
let toSt t = fmap (fmap (fmap showtime)) $ t
let sl = screeningListsFor w (DL.take 10 f)
let slc = DL.chunksOf 2 sl
let r = DL.take 3 . DL.filter disjoint . sequence
let toUtc = posixSecondsToUTCTime . fromIntegral . showtime
let f' = DL.foldr (\a b -> (fmap DL.concat . sequence $ a) : b) []

let v = fmap sequence (DL.chunksOf 2 sl)

:def! rg (\_ -> return ":r\n:g\n")
:def! Rg (\_ -> return ":r\n:g\n")

:def! ra (\_ -> return ":set -w\n:l test/Runner.hs\nrun")
:def! Ra (\_ -> return ":ra")
:def! T (\_ -> return ":t")

:def! rd (\t -> (return (":def! r (\\_ -> return (\":rt " ++ t ++ "\"))")))

:def! rt (\t -> return (":m Test.HUnit\n:l test/Test/" ++ t ++ ".hs\nrunTestTT tests"))

:def! rc (\t -> return (":m Test.HUnit\n:l test/Test/" ++ t ++ ".hs\nrunTestTT tests1"))

:def! rl (\t -> return (":m Test.HUnit\n:l tests/Test/" ++ t ++ ".hs\nrunTestTT lastTest"))

:def! b (\_ -> return (":l src/main.hs\n:set args build\nmain"))
:def! rb (\_ -> return (":l src/main.hs\n:set args rebuild\nmain"))

let fs sid = fromJust $ DL.find ((==sid) . screeningId) (elems screenings)
let s325 = fs 325
let s326 = fs 326
let s288 = fs 288
let mt f = mapThese f f
let other = fromJust .otherScreening
let ss = elems screenings
let s = DL.head $ DL.drop 100 ss
let s' = other s
let s1 = addScreening s M.empty
let s2 = addScreening (other s) s1
let s3 = pinScreening s s2
let s4 = pinScreening (fromJust (otherScreening s)) s3
let s5 = ruleOutScreening s s4
let (msp1:_) = M.elems s1
let (msp2:_) = M.elems s2
let (msp3:_) = M.elems s3
let (msp4:_) = M.elems s4
